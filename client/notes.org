* Tavis's Notes

** TODO
- graph the metrics
- add something that generates UI events
- add some state machine that consumes both UI events and 
  the request metrics
- enable on/off control of the metrics ws subscription


** talk focus

Reading the http://www.reactivemanifesto.org/ I think everything I
want to say falls under the 'loose coupling' benefits of 'going
reactive'. I'll talk primarily about the benefits of separating
intent/event and implementation/reaction from simplicity, flexibility,
introspection and debugging perspectives. E.g. how it reduces control
flow complexity and keeps what remains separate from the declaritive
core of the domain/ui models. I'll also mention location
transparency - something Roman and I highlighted in our talk last year
at Polyglot - and temporal transformations on events streams
(throttling, sampling, etc.).

I won't talk about scalability, low-latency, 'responsiveness',
throughput, or resilience. All yours :)
** rough outline
- WTF is 'reactive': snippet from Eric Meier's reactconf talk
- Overview of Reactive Manifesto and my focus on 'loose coupling'
- architect your applications - both domain code and UIs - around
  decoupled event streams instead of directly coupling the
  implementation/reaction to the event sources with callbacks.
  Jesus Facepalm
- Reactive Extensions are like jquery for event streams
- ...
** very rough initial brainstorm / notes on my talk:
- what is an event?
- define effects
- steams, sequences, pipes: iterables vs observables
- event streams are equivalent to input/output simplicity benefits of FP
- easy to understand, compose, debug and much more
- don't think of Rx as a way to chain callbacks!
- and for fuck's sake don't design by callback chaining
- better metaphors:
  - it is a means to plumb event pipelines together
  - treat async events like collections
  - transform / compose (zip, selectMany, merge) / query (where, any)
  - time handling: buffer, throttle, window functions
  - Rx provides gears like a machine to transform your input events into either
    - output events
    - or effects (.subscribe)
- separation of concerns: intent/behaviour, interface/implementation, event/reaction
- system state is a derived from events (ui, network, whatever) that have occurred
- learn to think in state machines
- frp / uis
- deterministic replay of non-deterministic original event stream
- a bit about React.js and how it's V-only philosophy fits well with what I've said
  and with Rx
  http://facebook.github.io/react/docs/thinking-in-react.html
** operators by category
 https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/categories.md
** querying
https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/querying.md
** resources to study before talk
http://futurejs.org/agenda/streaming-and-event-based-programming-using-frp-and-rxjs
https://github.com/Reactive-Extensions/FutureJS
http://blogs.endjin.com/2014/04/event-stream-manipulation-using-rx-part-1/
 good post with event diagrams

https://gist.github.com/ScottWeinstein/11149384
The Four Essential Eï¬€ects In Programming:
             One        Many
Synchronous  T/Try[T]   Iterable[T]
Asynchronous Future[T]  Observable[T]

http://sitr.us/2013/05/22/functional-reactive-programming-in-javascript.html
An Introduction to Functional Reactive Programming CM's talk':
 http://lanyrd.com/2013/nodepdx/schbpc/
http://weareadaptive.com/blog/2014/05/05/everything-is-a-stream/

https://www.youtube.com/watch?v=FqBq4uoiG0M
review intro material at https://github.com/Reactive-Extensions/RxJS

see http://neugierig.org/software/blog/2014/02/react-jsx-coffeescript.html
for notes on using React directly in coffeescript rather than via jsx
